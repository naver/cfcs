{"version":3,"file":"cfcs.min.js","sources":["../src/core/utils.ts","../src/reactive/const.ts","../src/reactive/detectDependencies.ts","../src/reactive/Observer.ts","../src/reactive/ComputedObserver.ts","../src/reactive/decorators/Observe.ts","../src/reactive/decorators/ReactiveSubscribe.ts","../src/reactive/inline.ts","../src/reactive/utils.ts","../src/dom/utils.ts","../src/reactive/adaptReactive.ts","../src/reactive/decorators/Computed.ts"],"sourcesContent":["/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\n\n\n/**\n * @hidden\n */\nexport function keys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\n/**\n * @hidden\n */\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\n/**\n * @hidden\n */\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\n\n/**\n * @hidden\n */\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\n\n/**\n * @hidden\n */\nexport function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport const OBSERVERS_PATH = \"__observers__\";\nexport const COMPUTED_PATH = \"__computed__\";\nexport const CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nexport const CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport {\n  CFCS_DETECTED_DEPENDENCIES,\n  CFCS_DETECTED_DEPENDENCIES_VERSION,\n} from \"./const\";\nimport { Observer } from \"./Observer\";\n\nexport interface Detected {\n  host: Observer<any>;\n  observers: Array<Observer<any>>;\n  push(observer: Observer<any>): void;\n}\n\nexport function getDetectedStack(): Array<Detected> {\n  // Version issues do not occur when you access the native object in the global.\n  (Object as any)[CFCS_DETECTED_DEPENDENCIES] = (Object as any)[CFCS_DETECTED_DEPENDENCIES] || {};\n  const versionList = (Object as any)[CFCS_DETECTED_DEPENDENCIES];\n\n  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n\n  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\n\nexport function getCurrentDetected(): Detected | undefined {\n  const stack = getDetectedStack();\n\n  return stack[stack.length - 1];\n}\n\nexport function detectDependencies(host: Observer<any>) {\n  const stack = getDetectedStack();\n  const observers: Array<Observer> = [];\n  const detected: Detected = {\n    host,\n    observers,\n    push(observer: Observer<any>) {\n      if (host !== observer && observers.indexOf(observer) === -1) {\n        observers.push(observer);\n      }\n    },\n  };\n\n  stack.push(detected);\n  return detected;\n}\n\nexport function endDetectDependencies() {\n  const stack = getDetectedStack();\n\n  return stack.pop();\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport Component from \"@egjs/component\";\nimport { getCurrentDetected } from \"./detectDependencies\";\n\ninterface EmitterEvents<Value> {\n  update: (value: Value, prevValue: Value) => void;\n}\n\n/**\n * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @see observe\n */\nexport class Observer<Value = any> {\n  protected _current: Value;\n  protected _emitter = new Component<EmitterEvents<Value>>();\n  /**\n   *\n   */\n  constructor(value?: Value) {\n    this._current = value as any;\n  }\n  /**\n   * return the current value.\n   */\n  public get current(): Value {\n    const currentDetected = getCurrentDetected();\n\n    currentDetected?.push(this);\n    return this._current as Value;\n  }\n  public set current(value: Value) {\n    this._setCurrent(value);\n  }\n  /**\n   * When the current value changes, the callback function is called.\n   */\n  public subscribe(callback: (value: Value, prevValue: Value) => void) {\n    this.current;\n    this._emitter.on(\"update\", callback);\n    return this;\n  }\n  /**\n   * Cancel the registered subscription through callback.\n   */\n  public unsubscribe(callback?: (value: Value, prevValue: Value) => void) {\n    this._emitter.off(\"update\", callback);\n    return this;\n  }\n  protected _setCurrent(value: Value) {\n    const prevValue = this._current;\n    const isUpdate = value !== prevValue;\n\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value, prevValue);\n    }\n  }\n  /**\n   * @hidden\n   */\n  public toString() {\n    return `${this.current}`;\n  }\n  /**\n   * @hidden\n   */\n  public valueOf() {\n    return this.current;\n  }\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { detectDependencies, endDetectDependencies } from \"./detectDependencies\";\nimport { Observer } from \"./Observer\";\n\n/**\n * @category Reactive\n * @hidden\n */\nexport class ComputedObserver<T> extends Observer<T> {\n  private _registered: Array<Observer<any>> = [];\n  /**\n   * @description Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */\n  constructor(private _computedCallback: () => T) {\n    super();\n\n    this._current = this.current;\n  }\n\n  get current() {\n    detectDependencies(this);\n    const value = this._computedCallback();\n    const results = endDetectDependencies()!;\n\n    this._registered.forEach(observer => {\n      observer.unsubscribe(this._onCheckUpdate);\n    });\n    results.observers.forEach(observer => {\n      observer.subscribe(this._onCheckUpdate);\n    });\n    this._registered = results.observers;\n\n    return value;\n  }\n\n  private _onCheckUpdate = () => {\n    this._setCurrent(this.current);\n  }\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { getObserver } from \"../utils\";\n\n\nfunction injectObserve(prototype: any, memberName: string, publicName = memberName) {\n  const nextAttributes: PropertyDescriptor = {\n    configurable: true,\n    get: function () {\n      return getObserver(this, publicName).current;\n    },\n    set: function (value: any) {\n      getObserver(this, publicName, value).current = value;\n    },\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  if (publicName !== memberName) {\n    Object.defineProperty(prototype, publicName, {\n      configurable: true,\n      get: function () {\n        return getObserver(this, publicName).current;\n      },\n    });\n  }\n}\n\nexport function Observe(protoype: any, memberName: string): void;\nexport function Observe(name?: string): (protoype: any, memberName: string) => void;\n/**\n * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n* ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  // The public name and state name are the same.\n  @Observe value1 = 1;\n  // If you want to set public name and private properties separately\n  @Observe(\"value2\") _value2 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\ninterface C\n```\n */\nexport function Observe(...args: any[]) {\n  if (args.length > 1) {\n    return injectObserve(args[0], args[1]);\n  }\n\n  return (prototype: any, memberName: string) => injectObserve(prototype, memberName, args[0]);\n}\n\n\nexport function Reactive(protoype: any, memberName: string): void;\nexport function Reactive(name?: string): (protoype: any, memberName: string) => void;\n/**\n * @hidden\n */\nexport function Reactive(...args: any[]) {\n  return Observe(...args);\n}\n\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { keys } from \"../../core\";\nimport { getObserver, getObservers } from \"../utils\";\n\n/**\n * @hidden\n */\nexport function injectReactiveSubscribe(object: Record<string, any>,) {\n  object[\"subscribe\"] = function (name: string, callback: (value: any) => void) {\n    this[name];\n    getObserver(this, name).subscribe(callback);\n  };\n  object[\"unsubscribe\"] = function (name?: string, callback?: (value: any) => void) {\n    if (!name) {\n      keys(getObservers(this)).forEach((observerName) => {\n        this.unsubscribe(observerName);\n      });\n      return;\n    }\n    if (!(name in this)) {\n      return;\n    }\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\n\n\n/**\n * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.\n * @category Reactive-Decorator\n * @see Observe\n * @example\n * ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  @Observe value1 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\n\ninterface Component extends ReactiveSubscribe<{\n  value1: number;\n  value2: number;\n}> {}\n\nconst component = new Component();\n\n// 1\nconsole.log(component.value1);\n\ncomponent.subscribe(\"value1\", nextValue => {\n  // When the change event occurs => (2, 2)\n  console.log(nextValue, component.value2);\n});\n```\n */\nexport function ReactiveSubscribe(Constructor: any) {\n  const prototype = Constructor.prototype;\n\n  injectReactiveSubscribe(prototype);\n}\n\n/**\n * `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.\n * @category Reactive\n */\nexport interface ReactiveSubscribe<State extends Record<string, any>> {\n  /**\n   * When the value of the property changes, the callback function is called.\n   */\n  subscribe<Name extends keyof State = keyof State>(\n    name: Name, callback: (value: State[Name]) => void): void;\n  /**\n   * Unregister the callback function corresponding to the property.\n   */\n  unsubscribe<Name extends keyof State = keyof State>(\n    name?: Name, callback?: (value: State[Name]) => void): void;\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { ComputedObserver } from \"./ComputedObserver\";\nimport { Observer } from \"./Observer\";\nimport { ExtractNever, isFunction, keys } from \"../core\";\nimport { Observe } from \"./decorators/Observe\";\nimport { injectReactiveSubscribe, ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { defineObservers, isObserver, setObserver } from \"./utils\";\n\n\ntype ConvertValue<Object extends Record<string, any>> = {\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];\n}\n\ntype PickObverser<Object extends Record<string, any>> = ExtractNever<{\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;\n}>;\n\n/**\n * @typedef\n * @category Reactive\n */\nexport type ParitalReactiveObject<Object extends Record<string, any>>\n  = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;\n\n\n/**\n * Result type of `reactive` function call\n * @category Reactive\n * @see reactive\n * @example\n *  ```js\n * import { reactive } from \"@cfcs/core\";\n *\n * // define reactive state\n * const obj = reactive({\n *   value1: 1,\n *   value2: 2,\n * });\n * ```\n */\nexport type ReactiveObject<Object extends Record<string, any>>\n= Object & ReactiveSubscribe<Object>;\n\nfunction makeReactiveObject<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n  all?: boolean,\n): ParitalReactiveObject<Object> {\n  const result = isFunction(setup) ? setup() : setup;\n  const reactiveObject: Record<string, any> = {};\n\n  defineObservers(reactiveObject);\n  keys(result).forEach((name: any) => {\n    const value = result[name];\n\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n    } else {\n      setObserver(reactiveObject, name, observe(value));\n    }\n    Observe(name)(reactiveObject, name);\n  });\n\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject as ParitalReactiveObject<Object>;\n}\n\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Makes all values into reactive objects.\n * @example\n * ```ts\n * import { reactive } from \"@cfcs/core\";\n *\n * const obj = reactive({\n *  value1: 1,\n *  value2: 2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * obj.value1 = 2;\n * ```\n */\nexport function reactive<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n): ReactiveObject<Object> {\n  return makeReactiveObject(setup, true) as ReactiveObject<Object>;\n}\n\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Only the values to which observer is applied are objects to which reactive is applied.\n * @example\n * ```ts\n * import { partialReactive, observe } from \"@cfcs/core\";\n *\n * const value1 = observe(1);\n * const value2 = observe(2);\n * const obj = partialReactive({\n *  value1,\n *  value2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * value1.current = 2;\n * ```\n */\nexport function partialReactive<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n): ParitalReactiveObject<Object> {\n  return makeReactiveObject(setup);\n}\n\n/**\n * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @example\n * ```ts\n * import { observe } from \"@cfcs/core\";\n *\n * const ob1 = observe(1);\n *\n * ob1.subscribe(nextValue => {\n *   console.log(nextValue);\n * });\n *\n * ob1.current = 2;\n * ```\n */\nexport function observe<Type>(defaultValue?: Type): Observer<Type> {\n  return new Observer<Type>(defaultValue);\n}\n\n/**\n * @hidden\n */\nexport function computed<Type>(computedCallback: () => Type) {\n  return new ComputedObserver(computedCallback);\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { COMPUTED_PATH, OBSERVERS_PATH } from \"./const\";\nimport { Observer } from \"./Observer\";\nimport { ReactiveMethods } from \"./types\";\nimport { isObject, Ref } from \"../core\";\nimport { observe } from \"./inline\";\nimport { ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\n\n/**\n * @hidden\n */\nexport function withReactiveMethods<\n  Instance,\n  Names extends keyof Partial<Instance>,\n  Return extends ReactiveMethods<Instance, Names>\n>(ref: Ref<Instance>, methods?: readonly Names[]): Return {\n  const obj: Record<any, any> = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(name => {\n    obj[name] = function (...args: any[]) {\n      const current: any = ref.current || ref.value;\n\n      return current[name](...args);\n    };\n  });\n  return obj as Return;\n}\n\n/**\n * @hidden\n */\nexport function defineObservers(instance: any) {\n  const observers: Record<string, Observer<any>> = {};\n\n  Object.defineProperty(instance, OBSERVERS_PATH, {\n    get() {\n      return observers;\n    },\n  });\n\n  return observers;\n}\n\n/**\n * @hidden\n */\nexport function getObservers(instance: any, isComputed?: boolean): Record<string, Observer<any>> {\n  if (!instance[OBSERVERS_PATH]) {\n    defineObservers(instance);\n  }\n  const observers = instance[OBSERVERS_PATH];\n\n  if (!isComputed) {\n    const computedList = instance?.constructor?.prototype?.[COMPUTED_PATH];\n\n    if (computedList) {\n      computedList.forEach(name => {\n        if (!(name in observers) && name in instance) {\n          instance[name];\n        }\n      });\n    }\n  }\n  return observers;\n}\n\n/**\n * @hidden\n */\nexport function getObserver(instance: any, name: string, defaultValue?: any): Observer<any> {\n  const observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\n\n/**\n * @hidden\n */\nexport function setObserver(instance: any, name: string, observer: Observer<any>) {\n  const observers = getObservers(instance);\n\n  observers[name] = observer;\n}\n\n/**\n * @description Whether that object is an observer instance\n * @category Reactive\n */\nexport function isObserver(val: any): val is Observer {\n  return val && isObject(val) && \"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n\n/**\n * @description Whether the object is reactive\n * @category Reactive\n */\nexport function isReactive(val: any): val is ReactiveSubscribe<any> {\n  return val && !isObserver(val) && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { isString, Ref } from \"../core\";\n\n/**\n * @hidden\n */\nexport function findTarget<Target extends Element = Element>(target: string | Target | Ref<Target> | null): Target | null {\n  let el!: Target;\n\n  if (!target) {\n    return null;\n  } if (isString(target)) {\n    el = document.querySelector<Target>(target)!;\n  } else if (target instanceof Element) {\n    el = target;\n  } else if (\"value\" in target || \"current\" in target) {\n    el = target.value! || target.current!;\n  }\n\n  return el;\n}\n\n/**\n * @description Sets the name of the class method to be exposed to the outside.\n * @category DOM\n * @return Property Decorator\n * @example\n * ```ts\n * import { withClassMethods } from \"@cfcs/core\";\n *\n * class YourFrameworkComponent {\n *   @withClassMethod(METHOD_NAMES)\n *   inst = new YourComponent();\n * }\n * ```\n */\nexport function withClassMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { isFunction, keys } from \"../core\";\nimport { Ref } from \"../core/types\";\nimport { ReactiveAdapter, ReactiveAdapterParam } from \"./ReactiveAdapter\";\nimport { ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { ReactiveEventCallback, ReactiveState } from \"./types\";\nimport { getObservers, withReactiveMethods } from \"./utils\";\nimport Component from \"@egjs/component\";\nimport { EventKey, EventTriggerParams } from \"@egjs/component/declaration/types\";\n\n/**\n * @category Reactive\n * @hidden\n */\nexport function adaptReactive<\n  Instance extends ReactiveSubscribe<Record<string, any>>,\n  State extends Record<string, any> = ReactiveState<Instance>,\n  Methods extends keyof Partial<Instance> = never,\n  Props = any,\n  Events extends Record<string, any> = {},\n>(adapter: ReactiveAdapterParam<Instance, State, Methods, Props, Events>, props?: () => Props) {\n  const objectAdapter: ReactiveAdapter<Instance, State, Methods, Props, Events> = isFunction(adapter) ? {\n    setup: adapter,\n  } : adapter;\n\n  function getProps(): Props {\n    return props?.() ?? objectAdapter.props?.() ?? objectAdapter.data?.() ?? {} as Props;\n  }\n\n  const eventEmitter = new Component<Events>();\n  const mountedHooks: Array<(props: Props, instance?: Instance | null) => Instance | void> = [];\n  const initHooks: Array<(instance: Instance, props: Props) => void> = [];\n  const destroyHooks: Array<(instance: Instance, props: Props) => void> = [];\n  const onHooks: Array<<EventName extends EventKey<Events>>(instance: Instance, eventName: EventName, listener: ReactiveEventCallback<Events, EventName>) => void | (() => void)> = [];\n  const instanceRef: Ref<Instance> = { current: null };\n  let offHooksList: Array<Array<() => void>> = [];\n  let initialState: State | null = null;\n  let eventNames: readonly (keyof Events)[] = [];\n  let methodNames: readonly Methods[] = [];\n\n\n  const onMounted = (callback: (props: Props, instance?: Instance | null) => Instance | void) => {\n    mountedHooks.push(callback);\n  };\n  const onInit = (callback: (instance: Instance, props: Props) => void) => {\n    initHooks.push(callback);\n  };\n  const onDestroy = (callback: (instance: Instance, props: Props) => void): void => {\n    destroyHooks.push(callback)\n  };\n  const on = (callback: <EventName extends EventKey<Events>>(instance: Instance, eventName: EventName, listener: ReactiveEventCallback<Events, EventName>) => void | (() => void)) => {\n    onHooks.push(callback);\n  };\n  const emit = <EventName extends EventKey<Events>>(eventName: EventName, ...params: EventTriggerParams<Events, EventName>) => {\n    eventEmitter.trigger(eventName, ...params);\n  };\n\n  const setInitialState = (state: State) => {\n    initialState = state;\n  };\n  const setEvents = (events: readonly (keyof Events)[]) => {\n    eventNames = events;\n  }\n  const setMethods = (methods: readonly Methods[]) => {\n    methodNames = methods;\n  }\n\n  if (objectAdapter.setup) {\n    instanceRef.current = objectAdapter.setup({\n      getProps,\n      setInitialState,\n      setEvents,\n      setMethods,\n      onMounted,\n      onDestroy,\n      onInit,\n      emit,\n      on,\n    }) || null;\n  }\n\n  if (objectAdapter.created) {\n    instanceRef.current = objectAdapter.created(getProps()) || null;\n  }\n\n  if (objectAdapter.events) {\n    setEvents(objectAdapter.events);\n  }\n  if (objectAdapter.state) {\n    setInitialState(objectAdapter.state);\n  }\n  if (objectAdapter.methods) {\n    setMethods(objectAdapter.methods);\n  }\n  if (objectAdapter.mounted) {\n    onMounted(objectAdapter.mounted);\n  }\n  if (objectAdapter.destroy) {\n    destroyHooks.push(objectAdapter.destroy);\n  }\n  if (objectAdapter.init) {\n    initHooks.push(objectAdapter.init);\n  }\n  if (objectAdapter.on) {\n    onHooks.push((instance, eventName, listener) => {\n      const off = objectAdapter.on!(instance, eventName, listener);\n\n      return () => {\n        off && off();\n        objectAdapter.off?.(instance, eventName, listener);\n      };\n    });\n  }\n\n  return {\n    events: () => eventNames,\n    state(): State {\n      const inst = instanceRef.current;\n\n      if (initialState) {\n        return initialState;\n      }\n      if (inst) {\n        const observers = getObservers(inst);\n\n        setInitialState(keys(observers).reduce((prev, cur) => {\n          prev[cur] = observers[cur].current;\n          return prev;\n        }, {} as any));\n      }\n      return initialState || {} as State;\n    },\n    instance() {\n      return instanceRef.current;\n    },\n    mounted(): void {\n      const props = getProps();\n\n      mountedHooks.forEach(hook => {\n        instanceRef.current = hook(props, instanceRef.current) || instanceRef.current;\n      });\n\n    },\n    init(): void {\n      // on events\n      const instance = instanceRef.current!;\n      const props = getProps();\n\n      offHooksList = (eventNames as string[]).map(eventName => {\n        const listener = (...params: any[]) => {\n          (eventEmitter as any).trigger(eventName, ...params);\n        };\n\n        const instance = instanceRef.current!;\n\n        return onHooks.map(hook => hook(instance, eventName, listener as any)).filter(Boolean) as Array<() => void>;\n      });\n\n      // init\n      initHooks.forEach(hook => {\n        hook(instance, props);\n      });\n    },\n    destroy(): void {\n      // off events\n      offHooksList.forEach(offHooks => {\n        offHooks.forEach(hook => {\n          hook();\n        });\n      });\n\n      // destroy\n      eventEmitter.off();\n      const instance = instanceRef.current!;\n      const props = getProps();\n\n      destroyHooks.forEach(hook => {\n        hook(instance, props);\n      });\n    },\n    methods() {\n      return withReactiveMethods<any, any, any>(instanceRef, methodNames);\n    },\n    on(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      eventEmitter.on(eventName, listener);\n    },\n    off(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      eventEmitter.off(eventName, listener);\n    },\n  };\n}\n","/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport { COMPUTED_PATH } from \"../const\";\nimport { computed } from \"../inline\";\nimport { getObserver, getObservers } from \"../utils\";\n\n\n/**\n * @description `Computed` is a property decorator.\n * Changes in computed state values are also recognized according to changes in observers used within the getter function.\n * You can detect its status through `.subscribe`.\n * @hidden\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n * ```ts\nconst ob1 = observe(0);\nconst ob2 = observe(1);\n\n// When\n@ReactiveSubscribe\nclass TestComputed {\n  @Computed\n  get ob3() {\n    return ob1.current + ob2.current;\n  }\n}\nconst inst = new TestComputed();\n\ninst.subscribe(\"ob3\", ob3 => {\n  console.log(ob3);\n});\n\nob1.current = 1;\n```\n */\nexport function Computed(prototype: any, memberName: string, attributes: PropertyDescriptor): PropertyDescriptor {\n  const get = attributes.get!;\n\n  function getComputed() {\n    const observers = getObservers(this, true);\n\n    if (!(memberName in observers)) {\n      observers[memberName] = computed(get.bind(this));\n    }\n    return getObserver(this, memberName).current;\n  }\n  const nextAttributes: PropertyDescriptor = {\n    configurable: true,\n    get: getComputed,\n  }\n\n  prototype[COMPUTED_PATH] ||= [];\n  const computedList = prototype[COMPUTED_PATH];\n\n  if (computedList.indexOf(memberName) === -1) {\n    computedList.push(memberName);\n  }\n  Object.defineProperty(prototype, memberName, nextAttributes);\n\n  return nextAttributes;\n}\n"],"names":["keys","obj","Object","isString","val","isObject","isFunction","OBSERVERS_PATH","COMPUTED_PATH","CFCS_DETECTED_DEPENDENCIES_VERSION","CFCS_DETECTED_DEPENDENCIES","getDetectedStack","versionList","Observer","value","this","_emitter","Component","_current","__proto","prototype","defineProperty","get","currentDetected","stack","length","push","set","_setCurrent","subscribe","callback","current","on","unsubscribe","off","prevValue","isUpdate","trigger","toString","concat","valueOf","ComputedObserver","_super","__extends","_computedCallback","_this","_registered","_onCheckUpdate","host","observers","detected","observer","indexOf","results","pop","forEach","injectObserve","memberName","publicName","configurable","getObserver","Observe","args","_i","arguments","injectReactiveSubscribe","object","name","getObservers","observerName","makeReactiveObject","setup","result","reactiveObject","defineObservers","isObserver","setObserver","observe","defaultValue","computed","computedCallback","withReactiveMethods","ref","methods","instance","isComputed","computedList","_b","_a","constructor","str","replace","all","letter","toUpperCase","target","el","document","querySelector","Element","apply","adapter","props","objectAdapter","getProps","_e","call","_c","_d","data","onMounted","mountedHooks","setInitialState","state","initialState","setEvents","events","eventNames","setMethods","methodNames","eventEmitter","initHooks","destroyHooks","onHooks","instanceRef","offHooksList","onDestroy","onInit","emit","eventName","params","created","mounted","destroy","init","listener","observers_1","inst","reduce","prev","cur","hook","map","__spreadArray","filter","Boolean","offHooks","attributes","nextAttributes","bind","Constructor"],"mappings":"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"}